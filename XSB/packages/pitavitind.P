/* File:      pitaprism.P
** Author(s): Fabrizio Riguzzi
** Contact:   fabrizio.riguzzi@unife.it,xsb-contact@cs.sunysb.edu
** 
** Copyright (C) Fabrizio Riguzzi and Terrance Swift
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** 
*/


% prism optimization
:- dynamic v/3.
:- import length/2,append/3,nth/3 from lists.
:- import check_ground/3 from error_handler.
:-dynamic '$p'/2,rule_n/1,var_n/1,setting/2.

:- set_prolog_flag(unknown,fail).
rule_n(1).

var_n(1).

setting(epsilon_parsing, 0.0001).
%:-yap_flag(unknown,fail).
setting(compiling,false).
/* compiling: true, failse */
setting(tabling_output,video).
/* video, call */

myor(e(E1,P1),e(_E2,P2),e(E1,P1)):-P1 >=P2,!.
myor(e(_E1,_P1),e(E2,P2),e(E2,P2)).

myequality(R,S,Probs,N,e([(R,S,N)],P)):-N1 is N+1,nth(N1,Probs,P).
myand(e(E1,P1),e(E2,P2),e(E3,P3)):-P3 is P1*P2,append(E1,E2,E3).
myret_prob(B,B).
myzero(e([],0)).
myone(e([],1)).
mybdd_not(e(E,P0),e([-E],P)):-P is 1- P0.

get_next_rule_number(R):-
	retract(rule_n(R)),
	R1 is R+1,
	assert(rule_n(R1)).
get_next_var_number(R):-
	retract(var_n(R)),
	R1 is R+1,
	assert(var_n(R1)).

	
myinit:-
	retractall(v(_,_,_,_)),
	abolish_all_tables.

prob(Goal,P):-
	myinit,
	add_bdd_arg(Goal,BDD,Goal1),
	(call(Goal1)->
		myret_prob(BDD,P)
	;
		P=0.0
	).


prob(Goal,P,CPUTime1,WallTime1):-
        cputime(CT0),
	walltime(WT0),
	myinit,
	add_bdd_arg(Goal,BDD,Goal1),
	(call(Goal1)->
		myret_prob(BDD,P)
	;
		P=0.0
	),
	cputime(CT1),
	CPUTime1 is CT1-CT0,
	walltime(WT1),
	WallTime1 is WT1-WT0.

s(Goal,P):-
        prob(Goal,P).

s(Goal,P,CPUTime1,0,WallTime1,0):-
        prob(Goal,P,CPUTime1,WallTime1).

load(File):-
        atom_concat(File,'_prismvit.P',FileP),
        atom_concat(File,'.cpl',FileCpl),
        parse(FileCpl,FileP),
        consult(FileP).

sum(A,B,C):-myor(A,B,C).

member_eq(Item, [Head|_Tail]) :-
        Item==Head, !.

member_eq(Item, [_Head|Tail]) :-
	member_eq(Item, Tail).


list2and([X], X) :-
        X\= (_, _) , !.

list2and([H|T], (H, Ta)) :- !,
	list2and(T, Ta).



list2or([X], X) :-
	X \= ( _ ; _ ) , !.

list2or([H|T], (H ; Ta)) :- !,
	list2or(T, Ta).

get_var_n(R,S,Probs,V):-
	(v(R,S,V,Probs)->
		true
	;	
		get_next_var_number(V),
		assert(v(R,S,V,Probs))
	).

generate_rules_fact([],_VC,_R,_Probs,_N,[]).

generate_rules_fact([(Head:_P1),('':_P2)],VC,R,Probs,N,[Clause]):-!,
	add_bdd_arg(Head,BDD,Head1),
	Clause=(Head1:-(myequality(R,VC,Probs,N,BDD))).

generate_rules_fact([(Head:_P)|T],VC,R,Probs,N,[Clause|Clauses]):-
	add_bdd_arg(Head,BDD,Head1),
	Clause = ( Head1 :- (myequality(R,VC,Probs,N,BDD))) ,
	N1 is N+1,
	generate_rules_fact(T,VC,R,Probs,N1,Clauses).

generate_clause(Head,Body,VC,R,Probs,BDDAnd,N,Clause):-
	add_bdd_arg(Head,BDD,Head1),
	Clause=(Head1:-(Body,myequality(R,VC,Probs,N,B),myand(B,BDDAnd,BDD))).

generate_rules([],_Body,_VC,_R,_Probs,_BDDAnd,_N,[]).

generate_rules([(Head:_P1),('':_P2)],Body,VC,R,Probs,BDDAnd,N,[Clause]):-!,
	generate_clause(Head,Body,VC,R,Probs,BDDAnd,N,Clause).

generate_rules([(Head:_P)|T],Body,VC,R,Probs,BDDAnd,N,[Clause|Clauses]):-
	generate_clause(Head,Body,VC,R,Probs,BDDAnd,N,Clause),
	N1 is N+1,
	generate_rules(T,Body,VC,R,Probs,BDDAnd,N1,Clauses).


process_body([],BDD,BDD,[]).

process_body([\+ H|T],BDD,BDD1,[\+ H|Rest]):-
	builtin(H),!,
	process_body(T,BDD,BDD1,Rest).

process_body([\+ H|T],BDD,BDD1,
	[(H1->mybdd_not(BDDH,BDDN);myone(BDDN)),myand(BDD,BDDN,BDD2)|Rest]):-!,
	add_bdd_arg(H,BDDH,H1),
	process_body(T,BDD2,BDD1,Rest).

process_body([H|T],BDD,BDD1,[H|Rest]):-
	builtin(H),!,
	process_body(T,BDD,BDD1,Rest).

process_body([H|T],BDD,BDD1,
	[H1,myand(BDD,BDDH,BDD2)|Rest]):-!,
	add_bdd_arg(H,BDDH,H1),
	process_body(T,BDD2,BDD1,Rest).



and_list([],B,B).
and_list([H|T],B0,B1):-
	and(B0,H,B2),
	and_list(T,B2,B1).

or_list([H],H):-!.

or_list([H|T],B):-
	or_list1(T,H,B).
		
or_list1([],B,B).
or_list1([H|T],B0,B1):-
	myor(B0,H,B2),
	or_list1(T,B2,B1).

/* set(Par,Value) can be used to set the value of a parameter */
set(Parameter,Value):-
	retract(setting(Parameter,_)),
	assert(setting(Parameter,Value)).



extract_vars(Variable, Var0, Var1) :- 
	var(Variable), !, 
	(member_eq(Variable, Var0) ->
		Var1 = Var0;
		append(Var0, [Variable], Var1)).

extract_vars(Term, Var0, Var1) :- 
	Term=..[_F|Args], 
	extract_vars_list(Args, Var0, Var1).



extract_vars_list([], Var, Var).

extract_vars_list([Term|Tail], Var0, Var1) :- 
	extract_vars(Term, Var0, Var), 
	extract_vars_list(Tail, Var, Var1).


difference([],_,[]).

difference([H|T],L2,L3):-
	member_eq(H,L2),!,
	difference(T,L2,L3).
	
difference([H|T],L2,[H|L3]):-
	difference(T,L2,L3).
	
add_bdd_arg(A,BDD,A1):-
	A=..[P|Args],
	append(Args,[BDD],Args1),
	A1=..[P|Args1],
	functor(A1,_,Arity),
	('$p'(P,Arity)->
		true
	;
		assert('$p'(P,Arity))
	).
add_bdd_arg_extra(A,BDD,A1,Cl):-
	A=..[P|Args],
	append(Args,[BDD],Args1),
	atom_concat(P,'$',P1),
	functor(A,_,Arity),
	A1=..[P1|Args1],
	(p(P,Arity)->
		Cl=[]
	;
		assert(p(P,Arity)),
		length(L,Arity),
		append(L,[B],L1),
		Head=..[P1|L1],
		append(L,[B1],L2),
		Body=..[P|L2],
		Cl=[(Head:- (bagof(B1,Body,List),or_list(List,B)))],
		(setting(tabling,on)->
			table_pred(A),
			A2=..[P1|Args],
			table_pred(A2)
		;
			true
		)
	).

table_pred(A):-	
	functor(A,P,Arity),
	Arity1 is Arity +1,
	functor(A1,P,Arity1),
	A1=..[_|Args],
	last(Args,myor/3-myzero/1),
	(setting(tabling_output,call)->
		call(table(A1))
	;
		write((:- table A1)),
		writeln('.')
	).
last([H],H):-!.

last([_H|T],L):-
	last(T,L).

process_head(HeadList, GroundHeadList) :- 
	ground_prob(HeadList), !,
	process_head_ground(HeadList, 0, GroundHeadList).
	 
process_head(HeadList, HeadList).



/* process_head_ground([Head:ProbHead], Prob, [Head:ProbHead|Null])
 * ----------------------------------------------------------------
 */
process_head_ground([Head:ProbHead], Prob, [Head:ProbHead|Null]) :-!,
	ProbLast is 1 - Prob - ProbHead,
	setting(epsilon_parsing, Eps), 
	EpsNeg is - Eps, 
	ProbLast > EpsNeg, 
	(ProbLast > Eps ->
		Null = ['':ProbLast];
		Null = []). 

process_head_ground([Head:ProbHead|Tail], Prob, [Head:ProbHead|Next]) :- 
	ProbNext is Prob + ProbHead, 
	process_head_ground(Tail, ProbNext, Next).

ground_prob([]).

ground_prob([_Head:ProbHead|Tail]) :- 
	check_ground(ProbHead,_,_), % Succeeds if there are no free variables in the term ProbHead.
	ground_prob(Tail).

get_probs([], []).

get_probs([_H:P|T], [P1|T1]) :- 
	P1 is P, 
	get_probs(T, T1).

builtin(_A is _B).
builtin(_A > _B).
builtin(_A < _B).
builtin(_A >= _B).
builtin(_A =< _B).
builtin(_A =:= _B).
builtin(_A =\= _B).
builtin(true).
builtin(false).
builtin(_A = _B).
builtin(_A==_B).
builtin(_A\=_B).
builtin(_A\==_B).
builtin(length(_L, _N)).
builtin(member(_El, _L)).
builtin(average(_L, _Av)).
builtin(max_list(_L, _Max)).
builtin(min_list(_L, _Max)).
builtin(nth0(_, _, _)).
builtin(nth(_, _, _)).
builtin(eraseall(_Id)).
builtin(recordzifnot(_Id, _Item, _)).

parse(FileIn,FileOut):-
	retractall('$p'(_,_)),
	open(FileIn,read,SI),
	read_clauses(SI,C),
	close(SI),
        set(compiling,true),
	process_clauses(C,[],C1),
        set(compiling,false),
	open(FileOut,write,SO),
        findall(p(P,A),'$p'(P,A),L),
	write_tab_dir(L,SO),
	write_clauses(C1,SO),
	close(SO).

process_clauses([end_of_file],C,C).

process_clauses([H|T],C0,C1):-
	(term_expansion(H,H1)->
		true
	;
		H1=H
	),
	(H1=[_|_]->
		append(C0,H1,C2)
	;
		append(C0,[H1],C2)
	),
	process_clauses(T,C2,C1).

read_clauses(S,[Cl|Out]):-
        read_term(S,Cl,[]),
	(Cl=end_of_file->
		Out=[]
	;
		read_clauses(S,Out)
	).

write_tab_dir([],S):-
        nl(S).

write_tab_dir([p(P,A)|T],S):-
        table_dir(P,A,Atom),
        write(S,':-table '),
        write(S,Atom),
        write(S,'.'),
        nl(S),
        write_tab_dir(T,S).

table_dir(P,Arity,Atom):-
        functor(Atom,P,Arity),
        Atom=..[_|Args],
        last(Args,myor/3-myzero/1).

write_clauses([],_).

write_clauses([H|T],S):-
	write(S,H),
	write(S,'.'),
	nl(S),
	write_clauses(T,S).

term_expansion((Head :- Body), Clauses):-
% disjunctive clause with more than one head atom
	setting(compiling,true),
	Head = (_;_), !, 
	list2or(HeadListOr, Head), 
	process_head(HeadListOr, HeadList), 
	list2and(BodyList, Body), 
	process_body(BodyList,One,BDDAnd,BodyList1),
	list2and(BodyList1,Body1),
	get_next_rule_number(R),
	get_probs(HeadList,Probs),
	extract_vars((Head:-Body),[],VC),
	generate_rules(HeadList,(myone(One),Body1),VC,R,Probs,BDDAnd,0,Clauses).

term_expansion((Head :- Body), Clauses) :- 
% disjunctive clause with a single head atom
	setting(compiling,true),
	((Head:-Body) \= ((user:term_expansion(_,_) ):- _ )),
	Head = (H:_), !, 
	list2or(HeadListOr, Head), 
	process_head(HeadListOr, HeadList), 
	list2and(BodyList, Body), 
	process_body(BodyList,One,BDDAnd,BodyList2),
	list2and(BodyList2,Body2),
	get_next_rule_number(R),
	get_probs(HeadList,Probs),
	extract_vars((Head:-Body),[],VC),
	generate_clause(H,(myone(One),Body2),VC,R,Probs,BDDAnd,0,Clauses).


term_expansion((Head :- Body),Clauses) :- 
% definite clause
	setting(compiling,true),
	((Head:-Body) \= ((user:term_expansion(_,_)) :- _ )),!,
	list2and(BodyList, Body), 
	process_body(BodyList,One,BDDAnd,BodyList2),
	list2and(BodyList2,Body2),
	add_bdd_arg(Head,BDDAnd,Head1),
	Clauses=(Head1 :- (myone(One),Body2)).
	

term_expansion(Head,Clauses) :- 
% disjunctive fact with more than one head atom
	setting(compiling,true),
	Head = (_;_),!, 
	list2or(HeadListOr, Head), 
	process_head(HeadListOr, HeadList), 
	extract_vars((Head),[],VC),
	get_next_rule_number(R),
	get_probs(HeadList,Probs),
	generate_rules_fact(HeadList,VC,R,Probs,0,Clauses).

term_expansion(Head,Clause) :- 
% disjunctive fact with a single head atom
	setting(compiling,true),
	(Head \= ((term_expansion(_,_)) :- _ )),
	Head = (H:_), !, 
	list2or(HeadListOr, Head), 
	process_head(HeadListOr, HeadList),
	extract_vars((Head),[],VC),
	get_next_rule_number(R),
	get_probs(HeadList,Probs),
	add_bdd_arg(H,BDD,Head1),
	Clause=(Head1:-(myequality(R,VC,Probs,0,BDD))).

term_expansion(Head, (Head1:-myone(One))) :- 
% definite fact
	setting(compiling,true),
	(Head \= ((term_expansion(_,_) ):- _ )),
	Head \= (:- table _ ),
	Head \= (:- import _),
	(Head\= end_of_file),!,
	add_bdd_arg(Head,One,Head1).

